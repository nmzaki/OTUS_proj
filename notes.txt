Урок Базовые типы данны
':=' - моржовый оператор, сокращает код, изучить самостоятельно
print(type(x)) - показывает тип данных переменных Х
метод - действия с переменной
// - деление нацело
% - деление с остатком
num = 786
print(number//10%10)    >> 8
** - возведение в степень
Операции с float в сыром виде выдают не точные остатки, в помощь импорт decimal
help(тип данных) - вывод справки
методы строк (их много):
#конкатенация - сложение строк
replace
string1 = 'python is the best'
print(string1.replace('t', 'T'))    >>pyThon is The besT
lower - перевод в нижний регистр
upper - верхний регистр
capitalize - перевод первой буквы в верхний регистр
strip - удаляет пробелы и перходы в конце и начале строки, бывает r/lstrip (справа/слева)
split - разделение строки по заданному параметру - по дефолту разделение по пробелу
isdigit - проверка строки на цифру - булевый вывод
count - подсчет подстрок в строке string.count('x')
index - показывает индекс искомой подстроки
print(string1.index[4/'t', 3]) - после запятой вводится индекс с которого начинать считать
find - поиск подстроки, возвращает индекс
интерполяция - f-строка "f'{} блабла бла {} бла бла'"
number = 2323534645634534543
print(len(str(number)) - переводим число в строку и получаем количество символов

!!!!изучи функцию enumetare!!!

Булевые операции:
or "+"
and "*"
None - тип данных состоящий из одного значения - существенного ничего


Операторы ветвления

индент - отсутп, табуляция в питоне, равна 4 пробелам, отделение строк кода для условий ветвления
if <условие>:
    блаблабла
elif <условие2>:
    блабла
else:
    блаблабла

if - обязательно
elif - опционально
else - опционально
тернарный оператор:
print('some text' if age > 18 else 'another text')


Урок Управляющие конструкции

Коллекции - контейнерный тип данных (изменяемый, объект изменяется):
list - список (!!! не массивы !!!), не имеет длины, содержит любые объекты, упорядоченный (есть индексы); имена коллекций заразервированные функции
методы изменяют список/объект, не создают новый
my_list = list()
my_list = [1,2,3,4,wfwe,True,[1,'g']]
print(type(my_list))
list\set\ comprehensions: my_list = [((i**2)\любое выражение) for i in range(10) ((if i%2) не обязательно)]
print(my_list)
my_list.append('new') - добавляет в конец списка
.insert(0, 'new') - добавляет в 0 индекс объект new
.remove(2) - удаление элемента по значению
.pop(0) - удаление по индексу, выдергивает из списка, можно переместить удаленный элемент в другую переменную
.extend() - конкатенация списков (сложение), переводит строки в список
.count(2) - подсчитывает количество заданных элементов
.index(2, 0) - возвращает индекс объекта, начинает с 0
.sort() - сортировка
.reverse() - обратная сортировка
.clear() - очистка списка
.copy() - копия списка (не работает со вложенными списками my_list = [1,2,3,[4,5]] - решается импортом deepcopy
срез - a[1::2]

tuple - кортеж; не изменяемый список, хранит любые типы данных и любое количество объектов, мало методов, есть конкатенация, создает новый кортеж
my_tuple = (1,2,3,4,5) - истинный кортеж
my_tuple = 1,2,3,4
my_tuple = [1,] - еденичный кортеж, можно без скобок
my_tuple = (1,2,3,[4,5])  - неистинный кортеж, имеет внутри изменяемый объект
my_yuple[4].append(7) - добавит в НЕизменяемый кортеж элемент
print(type(my_tuple))
.count()
.index()

set - множество; неупорядоченная коллекция, содержит уникальные элементы (исключает дупликацию объектов) - объединение, сложение, вычитание (конъюнкция, дизъюнкиця и тд)
Нельзя добавлять изменяемые объекты (списки, то есть нехэшируемые объекты)
много математических методов:
.intersenction - пересечение
.difference - разница
и т.д.
.add(5) - добавление в множество, упорядочивание по хэшу, а не классически.
a = set()
a = {1,2,3,4}

dict - словарь; содержит 2 объекта - ключ и значение, в роли ключей может быть любые неизменяемые объекты(int, float, bool...), ключи - уникальные (хэшируемые) элементы
значение - любое
a = {1:'1', 2:'2',3:'3'}
print(a[1]) - выведет значение первого ключа
a[4] = 'four' - добавляет в уже существующий словарь новую пару ключ\значение
.get('2') - безопасное обращение к словарю
.setdefault(1, 'one') - безопасное добавление
.copy - как в ...
.popitem() - возвращает последний добавленный элемент
.pop(3) - удаляет что то там
.fromkeys('ABCDEF', 0) - классовый метод, возвращает указанным ключам нулевое\указанное значение
.values() - обращение к значениям
.keys() - обращение к ключам
.update() - обновляет словарь, добавляет новые ключи:значения, накладывает инфо сверху
Цикловые методы словаря

globals() - функция, возвращающая глобальные переменные (является словарем)

Циклы:
num = 0
while num < 10:
    print(num)
    num += 1

while True: #бесконечный цикл с окончанием break (не всегда нужно так делать)
    print(num)
    num += 1
    if num > 300:
        break

num = 10
while num <= 300:
    num += 1
    if not num == 50:
        print('принял 50')
        break
        #continue
    print(num)
else:
    print('закончился самостоятельно')

for - переборка, конечный цикл




Урок 3 - Функции
        #Конспектируй когда есть время!!!
декораторы - изучить самостоятельно
замыкания - изучить самостоятельно
функция - объект,
def имя_функции(аргумент\аттрибут): - хороший тон до 7 аргументов
    йуйцу
    йцуцуйцу
    уйцуйц
имя_функции(аргумент) - вызов функции
